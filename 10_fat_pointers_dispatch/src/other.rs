use std::iter::Extend;

// can't use trait objects when generic methods are used
pub fn add_true(v: &mut dyn Extend<bool>) {
    v.extend(std::iter::once(true));
}

struct MyVec<T>(Vec<T>);

// end up with multiple copies of this method
// during monomorphization
impl<T> Extend<T> for MyVec<T> {
    fn extend<I>(&mut self, iter: I)
    where
        I: IntoIterator<Item = T>,
    {
        // ...        
    }

    // generated by compiler when users called extend on hash_map
    // fn extend_hashmap_intoiter<I>(&mut self, iter: std::collections::hash_map::IntoIter<bool>)
    // where
    //     I: IntoIterator<Item = T>,
    // {
            // ...
    // }
}

pub fn drop(v: &mut dyn Drop) {
    // when v goes out of scope Drop::drop is called
}

pub fn say_hei(s: Box<dyn AsRef<str>>) {
    // what happens when s goes out of scope?
    // every vtable includes drop
}